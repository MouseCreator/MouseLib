# MouseLib документація

## Структура фреймворку MouseLib

**MouseLib** - це фреймворк для написання web-застосунків на мові Java. Він покликаний скоротити витрати на розробку додатків, зберігаючи високу ефективність.
Фреймворк складається з 5 основних модулів:
- Ioc - реалізація Dependency Injection у вигляді Inversion-of-Control (IoC) контейнера
- Data - інструменти для взаємодії з базою даних на основі JDBC, можливості ORM
- Web - веб-сервер, створення контролерів для обробки запитів, маршрутизація
- Files - взаємодія з файлами, читання файлів з властивостями
- Tests - зручне використання IoC контейнера під час тестування

## Модуль IoC ##
Модуль IoC надає реалізацію IoC контейнера. Конфігурація відбувається за допомогою анотацій. Об'єкти, які створюються за допомогою контейнера називаються **картками**. Класи карток не можуть бути абстрактними (або інтерфейсами), не можуть бути внутрішніми класами.
### Початок роботи з MouseLib ###
Для початку роботи з MouseLib потрібно створити клас з довільною назвою (бажано, щоб вона була зрозумілою і мнемонічною). Цей клас позначаємо анотацією ```@Configuration```. Анотація ```@Configuration``` має поля для додаткових налаштувань, а саме:
- ```String basePackage()``` - вказує пакет, який буде проскановано під час ініціалізації IoC контейнера. Якщо залишити дане поле порожнім, то сканування буде пропущено
- ```Class<?>[] includeClasses()``` - класи, які потрібно додати до IoC контейнера окремо.
- ```MouseModules[] includeModules()``` - додавання інших модулів: ```DATA_MODULE, WEB_MODULE, TEST_MODULE, FILES_MODULE```.
- ```String name() - ім'я конфігурація```. Використовується, щоб відрізняти конфігурації між собою; різні конфігурації можуть мати різні набори карток.
- ```String[] includePackages()``` - пакети, які потрібно додати до IoC контейнера. Зауважимо, що в такому випадку будуть додані всі класи з даного пакету, навіть якщо вони не позначені анотаціями. Можна використовувати для автоматично згенерованих пакетів.

Щоб звернутися до IoC контейнера, використовується статичний метод ```IoC.getConfiguredInjector(Class<?> config)```. На вхід подається клас, позначений анотацією ```@Configuration```. Результатом цього методу є об'єкт класу ```Inj```, що надає доступ до карток.
### Конфігурація карток ###
Щоб клас був включений до класів карток, необхідно позначити його однією з анотацій: ```@Controller, @Service, @Dao, @Card```. Дані анотації мають однакові функції, назви додають семантичного забарвлення. ```@Controller``` використовується також у модулі Web, ці класи скануються додатково для пошуку кінцевих точок обробки http-запитів. В IoC контейнер поміщується інформація про супер-класи (включно з ```Object```) та інтерфейси, що реалізує даний клас картки. Наприклад, розглянемо клас ```A```, що є наслідником класу ```B``` та реалізує інтерфейс ```C```. Тоді об'єкт цього класу може повернутий під час виклику ```Inj.get(A.class), Inj.get(B.class), Inj.get(C.class)```, оскільки клас A може бути використаний замість абстракції більш високого рівня ```B``` та ```C```.
Розглянемо налаштування карток за допомогою анотацій.
- ```@Prototype``` - ставиться над класом. Такі картки будуть створюватися кожен раз, коли відбувається запит щодо них. Вони не зберігаються у контейнері.
- ```@Name``` - дозволяє обрати ім'я для картки. За домогою імені можна ідентифікувати конкретну реалізацію, якщо таких декілька. Для доступу до картки за іменем використовуються методи ```Inj.get(Class<T> clazz, String name)``` та ```Inj.getAll(Class<T> clazz, String name)```.
- ```@Primary``` - визначає пріорітетну реалізацію у випадку, якщо реалізацій даної абстракції декілька
- ```@UseRestriction``` - дозволяє визначити, які конфігурації можуть використовувати дану картку
- ```@Order``` - визначає сортування карток, коли відбувається запит на отримання декількох реалізацій даної абстракції. Якщо деякі картки не позначені цією анотацією, вони поміщуються в кінець списку.

Інші анотації стосуються полів, методів, конструкторів в класі картки.
- ```@Factory``` - ставиться над методом, дозволяє створювати інші картки. Тип повернення методу - картка, що створюється. Параметри методу - картки, що потрібні для створення цієї картки. Також метод може бути позначени @Prototype.
- ```@Auto``` - визначає межі застосування Dependency Injection. Анотація ставиться над конструктороми, методами та полями. Позначений конструктор викликається для створення початкового об'єкту картки. Такий конструктор має бути лише один. Позначені методи викликаються після цього. Параметри позначеного конструктора та методів мають бути картками. Далі ініціалізуються позначені поля.
- ```@Afer``` - ставиться над методами, що викликається після створення об'єкту. Параметрами методу мають бути картки. Дозволяє вирішувати циклічні залежності.
- ```@Collect``` - ставиться над параметрами та полями, якщо ті є колекціями. Вказує, які картки зберігаються в колекції. Підтримуються колекції ```java.util.List``` та ```java.util.Set```.
- ```@UseNamed``` - ставиться над параметрами та полями, дозволяє використовувати іменовані реалізації.

...
